!function(e){var n={};function t(i){if(n[i])return n[i].exports;var r=n[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,t),r.l=!0,r.exports}t.m=e,t.c=n,t.d=function(e,n,i){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:i})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(t.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var r in e)t.d(i,r,function(n){return e[n]}.bind(null,r));return i},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=4)}([function(e,n,t){"use strict";var i=this&&this.__createBinding||(Object.create?function(e,n,t,i){void 0===i&&(i=t),Object.defineProperty(e,i,{enumerable:!0,get:function(){return n[t]}})}:function(e,n,t,i){void 0===i&&(i=t),e[i]=n[t]}),r=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,"default",{enumerable:!0,value:n})}:function(e,n){e.default=n}),a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)"default"!==t&&Object.hasOwnProperty.call(e,t)&&i(n,e,t);return r(n,e),n};Object.defineProperty(n,"__esModule",{value:!0}),n.getGameModel=void 0;const s=a(t(1));const o=new class{constructor(){this.money=0,this.settings={terrainSettings:{settingsChanged:!1,chunkSize:s.chunkSize.x,chunkRange:s.chunkRange}},this.options={terrainOptions:{chunkSizeOptions:[32,64,128,256],chunkRangeOptions:[1,2,3,4,5,6]}}}addMoney(e){this.money+=e}};n.getGameModel=function(){return o}},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.maximumGrass=n.maximumTrees=n.noiseSeed=n.chunkRange=n.chunkSize=n.mountainMod=n.heights=void 0,n.heights={water:4.3,sand:5,plainsMin:4,plainsMax:25},n.mountainMod=n.heights.plainsMax-(n.heights.plainsMin+(n.heights.plainsMax-n.heights.plainsMin)/4),n.chunkSize={x:128,y:128},n.chunkRange=3,n.noiseSeed=1024,n.maximumTrees=75,n.maximumGrass=1e3},function(e,n){e.exports=THREE},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.getTreeGeometery=n.getLandTexture=n.getHeight=void 0;const i=t(1);n.getHeight=function(e,n){let t=25*noise.simplex2(e/100,n/100)+25+1.5*noise.simplex2(e/8,n/8)+30*noise.simplex2(e/1200,n/1200)+5,r=i.heights.plainsMin+(t-i.heights.plainsMin)/4;return t>i.heights.plainsMax?Math.pow(r,1.4)-13.5:r},n.getLandTexture=function(e,n,t){if(t<i.heights.water)return 0;if(t<i.heights.sand+.5)return 1;if(t<i.heights.sand+1)return 1+2*(t-(i.heights.sand+.5));let r=3+3*noise.simplex2(e/20,n/20);if(t>i.heights.plainsMax+3+r)return 4;if(t>i.heights.plainsMax+2+r)return t-(i.heights.plainsMax+2+r)+3;let a=5+5*noise.simplex2(e/15,n/15);return t>i.mountainMod+a?3:t>i.mountainMod+a-1?t-(i.mountainMod+a-1)+2:2},n.getTreeGeometery=function(){const e=new THREE.Color(2853674),n=new THREE.Color(5056285),t=new THREE.Geometry,i=new THREE.ConeGeometry(1,2,8);i.faces.forEach(n=>n.color.set(e)),i.translate(0,4,0),t.merge(i);const r=new THREE.ConeGeometry(1.2,2,8);r.faces.forEach(n=>n.color.set(e)),r.translate(0,3,0),t.merge(r);const a=new THREE.ConeGeometry(1.4,2,8);a.faces.forEach(n=>n.color.set(e)),a.translate(0,2,0),t.merge(a);const s=new THREE.CylinderGeometry(.3,.3,3);s.translate(0,-.5,0),s.faces.forEach(e=>e.color.set(n)),t.merge(s);let o=new THREE.BufferGeometry;return o.fromGeometry(t),o}},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const i=t(0),r=t(5);angular.module("delivery",[]).controller("deliveryController",(function(){this.gameModel=i.getGameModel(),this.menus={settings:!1},this.hideMenus=function(){this.menus.settings=!1},this.showMenu=function(e){switch(this.hideMenus(),e){case"settings":this.menus.settings=!0}},r.startApplication()}))},function(e,n,t){"use strict";var i=this&&this.__createBinding||(Object.create?function(e,n,t,i){void 0===i&&(i=t),Object.defineProperty(e,i,{enumerable:!0,get:function(){return n[t]}})}:function(e,n,t,i){void 0===i&&(i=t),e[i]=n[t]}),r=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,"default",{enumerable:!0,value:n})}:function(e,n){e.default=n}),a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)"default"!==t&&Object.hasOwnProperty.call(e,t)&&i(n,e,t);return r(n,e),n};Object.defineProperty(n,"__esModule",{value:!0}),n.startApplication=void 0,t(6);const s=a(t(2)),o=a(t(10)),c=a(t(13)),u=t(14),l=t(0);n.startApplication=function(){l.getGameModel();const e=new s.Scene;let n=new o.Terrain(e);const t=new u.Controls,i=new c.MyCamera(e,t,n);t.camera=i;const r=new s.WebGLRenderer({antialias:!1});r.setSize(window.innerWidth,window.innerHeight);let a=new s.Color(6658234),d=new s.Color(6216);e.background=new s.Color(0,0,0),document.body.appendChild(r.domElement);let h=new s.SpotLight(16777181,.6,100,.8,.5,1);i.camera.add(h),h.position.set(0,0,3),h.target=i.camera;let f=new s.Group;e.add(f);let p=new s.DirectionalLight(15658717,.5);p.position.y=1e3,p.position.z=1e3,p.target=i.camera,f.add(p);var m=(new s.TextureLoader).load("img/sun.png"),g=new s.SpriteMaterial({map:m}),v=new s.Sprite(g);v.scale.multiplyScalar(500),f.add(v),v.position.copy(p.position);var _=(new s.TextureLoader).load("img/moon.png"),x=new s.SpriteMaterial({map:_}),y=new s.Sprite(x);y.scale.multiplyScalar(100),y.position.y=-1e3,y.position.z=-250,f.add(y);const b=1e5*Math.PI*2;let M=0;var w=0,k=0;let S=0,L=0;!function o(){requestAnimationFrame(o),function(){S=Date.now();let o=Math.min((S-L)/1e3,1);L=S,function(){let n=S/-1e5;f.rotation.z=n,f.position.x=i.camera.position.x,f.position.z=i.camera.position.z,f.position.y=100,M=S%b*24/b,M+=12,M>24&&(M-=24),t.flashLight?h.intensity=.6:h.intensity=0;let r=new s.Vector3;p.getWorldPosition(r);let o=0;o=Math.min((r.y+200)/1e3,1),e.background.setRGB(o*a.r+d.r,o*a.g+d.g,o*a.b+d.b)}(),function(){if(20==++w){var e=document.getElementById("fps"),n=document.getElementById("posX"),t=document.getElementById("posY"),a=document.getElementById("calls"),s=document.getElementById("speed"),o=document.getElementById("time");if(e){var c=1e3/((S-k)/20);e.innerText=Math.round(c).toString(),n.innerText=i.camera.position.x.toFixed(2),t.innerText=i.camera.position.z.toFixed(2)+" z:"+i.camera.position.y.toFixed(2),a.innerText=r.info.render.calls.toString(),s.innerText=i.speed.length().toFixed(2).toString(),o.innerText=(M<10?"0":"")+Math.floor(M)+":"+(Math.floor(M%1*60)<10?"0":"")+Math.floor(M%1*60),k=S,w=0}}}(),n.updateChunks(o,i.camera),i.handleCameraMove(o),r.render(e,i.camera)}()}(),window.onresize=function(){i.camera.aspect=window.innerWidth/window.innerHeight,i.camera.updateProjectionMatrix(),r.setSize(window.innerWidth,window.innerHeight)}}},function(e,n,t){var i=t(7),r=t(8);"string"==typeof(r=r.__esModule?r.default:r)&&(r=[[e.i,r,""]]);var a={insert:"head",singleton:!1};i(r,a);e.exports=r.locals||{}},function(e,n,t){"use strict";var i,r=function(){return void 0===i&&(i=Boolean(window&&document&&document.all&&!window.atob)),i},a=function(){var e={};return function(n){if(void 0===e[n]){var t=document.querySelector(n);if(window.HTMLIFrameElement&&t instanceof window.HTMLIFrameElement)try{t=t.contentDocument.head}catch(e){t=null}e[n]=t}return e[n]}}(),s=[];function o(e){for(var n=-1,t=0;t<s.length;t++)if(s[t].identifier===e){n=t;break}return n}function c(e,n){for(var t={},i=[],r=0;r<e.length;r++){var a=e[r],c=n.base?a[0]+n.base:a[0],u=t[c]||0,l="".concat(c," ").concat(u);t[c]=u+1;var d=o(l),h={css:a[1],media:a[2],sourceMap:a[3]};-1!==d?(s[d].references++,s[d].updater(h)):s.push({identifier:l,updater:g(h,n),references:1}),i.push(l)}return i}function u(e){var n=document.createElement("style"),i=e.attributes||{};if(void 0===i.nonce){var r=t.nc;r&&(i.nonce=r)}if(Object.keys(i).forEach((function(e){n.setAttribute(e,i[e])})),"function"==typeof e.insert)e.insert(n);else{var s=a(e.insert||"head");if(!s)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");s.appendChild(n)}return n}var l,d=(l=[],function(e,n){return l[e]=n,l.filter(Boolean).join("\n")});function h(e,n,t,i){var r=t?"":i.media?"@media ".concat(i.media," {").concat(i.css,"}"):i.css;if(e.styleSheet)e.styleSheet.cssText=d(n,r);else{var a=document.createTextNode(r),s=e.childNodes;s[n]&&e.removeChild(s[n]),s.length?e.insertBefore(a,s[n]):e.appendChild(a)}}function f(e,n,t){var i=t.css,r=t.media,a=t.sourceMap;if(r?e.setAttribute("media",r):e.removeAttribute("media"),a&&btoa&&(i+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(a))))," */")),e.styleSheet)e.styleSheet.cssText=i;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(i))}}var p=null,m=0;function g(e,n){var t,i,r;if(n.singleton){var a=m++;t=p||(p=u(n)),i=h.bind(null,t,a,!1),r=h.bind(null,t,a,!0)}else t=u(n),i=f.bind(null,t,n),r=function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)};return i(e),function(n){if(n){if(n.css===e.css&&n.media===e.media&&n.sourceMap===e.sourceMap)return;i(e=n)}else r()}}e.exports=function(e,n){(n=n||{}).singleton||"boolean"==typeof n.singleton||(n.singleton=r());var t=c(e=e||[],n);return function(e){if(e=e||[],"[object Array]"===Object.prototype.toString.call(e)){for(var i=0;i<t.length;i++){var r=o(t[i]);s[r].references--}for(var a=c(e,n),u=0;u<t.length;u++){var l=o(t[u]);0===s[l].references&&(s[l].updater(),s.splice(l,1))}t=a}}}},function(e,n,t){(n=t(9)(!1)).push([e.i,"/* Styles go here. */\r\n\r\nhtml,\r\nbody {\r\n  margin: 0;\r\n  padding: 0;\r\n  font-family: Arial, Helvetica, sans-serif;\r\n  background-color: black;\r\n  color:#ccc;\r\n  user-select: none;\r\n}\r\n\r\ncanvas {\r\n  display: block;\r\n  position: fixed;\r\n  top:0;\r\n  left:0;\r\n  z-index: -50;\r\n}\r\n\r\ndiv.menu {\r\n  position: absolute;\r\n  top:50%;\r\n  left:50%;\r\n  transform: translate(-50%,-50%);\r\n  background: rgba(0, 0, 0, 0.8);\r\n  padding: 15px;\r\n}\r\n\r\ndiv.menu div.section {\r\n  margin:15px;\r\n}\r\n\r\ndiv.menu select { \r\n  float: right;\r\n  margin-left: 15px;\r\n}\r\n\r\ndiv.buttons {\r\n  position: absolute;\r\n  bottom: 15px;\r\n  right: 15px;\r\n}",""]),e.exports=n},function(e,n,t){"use strict";e.exports=function(e){var n=[];return n.toString=function(){return this.map((function(n){var t=function(e,n){var t=e[1]||"",i=e[3];if(!i)return t;if(n&&"function"==typeof btoa){var r=(s=i,o=btoa(unescape(encodeURIComponent(JSON.stringify(s)))),c="sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(o),"/*# ".concat(c," */")),a=i.sources.map((function(e){return"/*# sourceURL=".concat(i.sourceRoot||"").concat(e," */")}));return[t].concat(a).concat([r]).join("\n")}var s,o,c;return[t].join("\n")}(n,e);return n[2]?"@media ".concat(n[2]," {").concat(t,"}"):t})).join("")},n.i=function(e,t,i){"string"==typeof e&&(e=[[null,e,""]]);var r={};if(i)for(var a=0;a<this.length;a++){var s=this[a][0];null!=s&&(r[s]=!0)}for(var o=0;o<e.length;o++){var c=[].concat(e[o]);i&&r[c[0]]||(t&&(c[2]?c[2]="".concat(t," and ").concat(c[2]):c[2]=t),n.push(c))}},n}},function(e,n,t){"use strict";var i=this&&this.__createBinding||(Object.create?function(e,n,t,i){void 0===i&&(i=t),Object.defineProperty(e,i,{enumerable:!0,get:function(){return n[t]}})}:function(e,n,t,i){void 0===i&&(i=t),e[i]=n[t]}),r=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,"default",{enumerable:!0,value:n})}:function(e,n){e.default=n}),a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)"default"!==t&&Object.hasOwnProperty.call(e,t)&&i(n,e,t);return r(n,e),n},s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.Terrain=void 0;const o=a(t(2)),c=t(11),u=s(t(12)),l=t(1),d=t(3),h=t(0);noise.seed(l.noiseSeed);const f=h.getGameModel(),p=(new o.TextureLoader).load("img/grass.png"),m=(new o.TextureLoader).load("img/grassblade.png"),g=(new o.TextureLoader).load("img/grassblade2.png"),v=(new o.TextureLoader).load("img/grassblade3.png"),_=(new o.TextureLoader).load("img/gravel.png"),x=(new o.TextureLoader).load("img/sand.png"),y=(new o.TextureLoader).load("img/water.png"),b=(new o.TextureLoader).load("img/snow.png");y.wrapS=o.MirroredRepeatWrapping,y.wrapT=o.MirroredRepeatWrapping,_.wrapS=b.wrapS=x.wrapS=p.wrapS=o.RepeatWrapping,_.wrapT=b.wrapT=x.wrapT=p.wrapT=o.RepeatWrapping,m.magFilter=_.magFilter=b.magFilter=x.magFilter=p.magFilter=o.NearestFilter;const M=o.UniformsUtils.merge([o.ShaderLib.phong.uniforms]);M.texture1={type:"t",value:y},M.time={type:"f",value:1},M.amp={type:"f",value:.004};const w=new o.ShaderMaterial({uniforms:M,vertexShader:c.MyShaders.WaterVertexShader,fragmentShader:c.MyShaders.WaterFragmentShader,lights:!0}),k=o.UniformsUtils.merge([o.ShaderLib.standard.uniforms]);k.grassTexture={type:"t",value:p},k.sandTexture={type:"t",value:x},k.snowTexture={type:"t",value:b},k.gravelTexture={type:"t",value:_};const S=o.UniformsUtils.merge([o.ShaderLib.standard.uniforms]);S.texture1={type:"t",value:m},S.texture2={type:"t",value:g},S.texture3={type:"t",value:v},S.time={type:"f",value:0},S.amp={type:"f",value:.5},S.roughness.value=1;const L=new o.ShaderMaterial({uniforms:k,vertexShader:c.MyShaders.LandVertexShader,fragmentShader:c.MyShaders.LandFragmentShader,lights:!0,side:o.BackSide});var C=new o.PlaneBufferGeometry(320,320,480,1),D=new o.Mesh(C,w);D.position.y=l.heights.water+.55,D.rotation.x=-.5*Math.PI;var T=new o.PlaneBufferGeometry(6400,6400,1,1),z=new o.Mesh(T,new o.MeshPhongMaterial({map:y}));z.position.y=l.heights.water+.5,z.rotation.x=-.5*Math.PI;class P{constructor(e,n,t){this.x=e,this.y=n,this.geo=new o.PlaneBufferGeometry(t,t,t,t),this.planeMesh=new o.Mesh(this.geo,L),this.discarded=!1}}n.Terrain=class{constructor(e){this.chunkRange=1,this.chunkSize=32,this.chunks=[],this.chunkMap=[],this.discardedChunks=[],this.lastCubeCenter={x:1,y:1},this.lastGrassCenter={x:0,y:0},this.chunkRange=f.settings.terrainSettings.chunkRange,this.chunkSize=f.settings.terrainSettings.chunkSize,this.group=new o.Group,e.add(this.group),this.waterGroup=new o.Group,this.waterGroup.add(z),this.waterGroup.add(D),this.group.add(this.waterGroup),this.terrainGroup=new o.Group,this.group.add(this.terrainGroup),this.grassMesh=function(){let e=new o.PlaneBufferGeometry(.5,.5);return new o.InstancedMesh(e,new o.ShaderMaterial({uniforms:S,side:o.DoubleSide,vertexShader:c.MyShaders.GrassVertexShader,fragmentShader:c.MyShaders.GrassFragmentShader,transparent:!0,alphaTest:.5,lights:!0}),l.maximumGrass)}(),this.terrainGroup.add(this.grassMesh),this.treeMesh=new o.InstancedMesh(d.getTreeGeometery(),new o.MeshLambertMaterial({vertexColors:!0,reflectivity:0}),l.maximumTrees),this.terrainGroup.add(this.treeMesh),this.terrainWorker=new u.default;let n=this;this.terrainWorker.onmessage=function(e){switch(e.data.type){case"grass":n.processGrass(e.data.grassMatrices,e.data.grassTextures,e.data.treeMatrices);break;case"land":n.processChunk(e.data.x,e.data.y,e.data.pa,e.data.landTextures,e.data.size)}}}isWater(e){return e<l.heights.water+.55}createChunkObject(e,n){if(this.discardedChunks.length>0){let t=this.discardedChunks.pop();return t.x=e,t.y=n,t.discarded=!1,t.processed=!1,t}let t=new P(e,n,this.chunkSize);return this.terrainGroup.add(t.planeMesh),t.processed=!1,t}fixChunkNormals(e){e.geo.computeBoundingSphere(),e.geo.computeVertexNormals();let n,t,i,r=this.chunkSize+1,a=this.chunkSize+1,s=e.geo.getAttribute("normal");if(this.chunkMap[e.x-this.chunkSize]&&this.chunkMap[e.x-this.chunkSize][e.y]&&(n=this.chunkMap[e.x-this.chunkSize][e.y],n.processed)){t=n.geo.getAttribute("normal");for(let e=0;e<a;e++)i=(r-1)*a+e,s.setXYZ(e,t.getX(i),t.getY(i),t.getZ(i))}if(this.chunkMap[e.x+this.chunkSize]&&this.chunkMap[e.x+this.chunkSize][e.y]&&(n=this.chunkMap[e.x+this.chunkSize][e.y],n.processed)){t=n.geo.getAttribute("normal");for(let e=0;e<a;e++)i=e,s.setXYZ((r-1)*a+e,t.getX(i),t.getY(i),t.getZ(i))}if(this.chunkMap[e.x]&&this.chunkMap[e.x][e.y+this.chunkSize]&&(n=this.chunkMap[e.x][e.y+this.chunkSize],n.processed)){t=n.geo.getAttribute("normal");for(let e=0;e<r;e++)i=e*a,s.setXYZ(e*a+(r-1),t.getX(i),t.getY(i),t.getZ(i))}if(this.chunkMap[e.x]&&this.chunkMap[e.x][e.y-this.chunkSize]&&(n=this.chunkMap[e.x][e.y-this.chunkSize],n.processed)){t=n.geo.getAttribute("normal");for(let e=0;e<r;e++)i=e*a+(r-1),s.setXYZ(e*a,t.getX(i),t.getY(i),t.getZ(i))}e.geo.getAttribute("position").needsUpdate=!0}processGrass(e,n,t){let i=new Float32Array(n);this.grassMesh.count=i.length,this.grassMesh.instanceMatrix.copyArray(new Float32Array(e)),this.grassMesh.geometry.setAttribute("tex",new o.InstancedBufferAttribute(i,1,!1,1)),this.grassMesh.instanceMatrix.needsUpdate=!0,this.treeMesh.instanceMatrix.copyArray(new Float32Array(t)),this.treeMesh.instanceMatrix.needsUpdate=!0}processChunk(e,n,t,i,r){if(r!=this.chunkSize||!this.chunkMap[e]||!this.chunkMap[e][n])return;let a=this.chunkMap[e][n];a.geo.setAttribute("position",new o.BufferAttribute(new Float32Array(t),3,!0)),a.geo.setAttribute("tex",new o.BufferAttribute(new Float32Array(i),1,!1)),this.fixChunkNormals(a),a.processed=!0}createChunk2(e,n){let t=this.createChunkObject(e,n);this.terrainWorker.postMessage(["land",e,n,this.chunkSize]),this.chunks.push(t),this.chunkMap[e]||(this.chunkMap[e]=[]),this.chunkMap[e][n]=t}destroyChunk(e){e.discarded=!0,this.discardedChunks.push(e),delete this.chunkMap[e.x][e.y],0==Object.keys(this.chunkMap[e.x]).length&&delete this.chunkMap[e.x]}destroyAllChunks(){for(var e=0;e<this.chunks.length;e++){let n=this.chunks[e];n.planeMesh.geometry.dispose(),this.terrainGroup.remove(n.planeMesh)}this.chunks=[],this.discardedChunks=[],this.chunkMap=[]}updateSettings(){this.chunkRange=f.settings.terrainSettings.chunkRange,this.chunkSize=f.settings.terrainSettings.chunkSize,f.settings.terrainSettings.settingsChanged=!1,this.lastCubeCenter={x:1,y:1},this.destroyAllChunks()}updateChunks(e,n){f.settings.terrainSettings.settingsChanged&&this.updateSettings(),M.time.value+=60*e,S.time.value+=60*e;let t=Math.round(n.position.x),i=Math.round(n.position.z);if((Math.abs(t-this.waterGroup.position.x)>64||Math.abs(i-this.waterGroup.position.z)>64)&&(this.waterGroup.position.x=t,this.waterGroup.position.z=i),this.lastCubeCenter.x==t&&this.lastCubeCenter.y==i)return;(Math.abs(t-this.lastGrassCenter.x)>3||Math.abs(i-this.lastGrassCenter.y)>3)&&(this.terrainWorker.postMessage(["grass",t,i,100,200]),this.lastGrassCenter.x=t,this.lastGrassCenter.y=i);let r=Math.round(t/this.chunkSize)*this.chunkSize,a=Math.round(i/this.chunkSize)*this.chunkSize;var s=r-this.chunkRange*this.chunkSize,o=r+this.chunkRange*this.chunkSize,c=a-this.chunkRange*this.chunkSize;let u=a+this.chunkRange*this.chunkSize;for(var l=0;l<this.chunks.length;l++)if(this.chunks[l].x<s||this.chunks[l].x>o||this.chunks[l].y<c||this.chunks[l].y>u)return this.destroyChunk(this.chunks[l]),void this.chunks.splice(l,1);for(l=-this.chunkRange;l<=this.chunkRange;l++)for(var d=r+l*this.chunkSize,h=-this.chunkRange;h<=this.chunkRange;h++){var p=a+h*this.chunkSize;if(!this.chunkMap[d]||!this.chunkMap[d][p])return void this.createChunk2(d,p)}this.lastCubeCenter.x=t,this.lastCubeCenter.y=i}}},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.MyShaders=void 0,n.MyShaders={GrassVertexShader:"\n          #define MYLAND\n          varying vec3 vLightFront;\n          varying vec3 vIndirectFront;\n          #ifdef DOUBLE_SIDED\n              varying vec3 vLightBack;\n              varying vec3 vIndirectBack;\n          #endif\n          #include <common>\n          #include <uv_pars_vertex>\n          #include <uv2_pars_vertex>\n          #include <envmap_pars_vertex>\n          #include <bsdfs>\n          #include <lights_pars_begin>\n          #include <color_pars_vertex>\n          #include <fog_pars_vertex>\n          #include <morphtarget_pars_vertex>\n          #include <skinning_pars_vertex>\n          #include <shadowmap_pars_vertex>\n          #include <logdepthbuf_pars_vertex>\n          #include <clipping_planes_pars_vertex>\n\n          varying vec3 vUv;\n          attribute float tex;\n          varying float texture;\n          uniform float time;\n          uniform float amp;\n\n          void main() {\n\n              vUv = position;\n              texture = tex;\n      \n              #include <uv_vertex>\n              #include <uv2_vertex>\n              #include <color_vertex>\n              #include <beginnormal_vertex>\n              #include <morphnormal_vertex>\n              #include <skinbase_vertex>\n              #include <skinnormal_vertex>\n              #include <defaultnormal_vertex>\n              #include <begin_vertex>\n              #include <morphtarget_vertex>\n              #include <skinning_vertex>\n              \n              vec4 mvPosition = vec4( transformed, 1.0 );\n              if (position.y > 0.0) {\n                float freq = 0.2 * min(max(instanceMatrix[0].x, 0.7), 1.8);\n                float angle = ((time * 0.2) + (position.y * 8.0)) * freq;\n                angle += instanceMatrix[3].x;\n                mvPosition.z += cos(angle) * amp * freq;\n              }\n\n              #ifdef USE_INSTANCING\n                mvPosition = instanceMatrix * mvPosition;\n              #endif\n\n              mvPosition = modelViewMatrix * mvPosition;              \n              gl_Position = projectionMatrix * mvPosition;\n              #include <logdepthbuf_vertex>\n              #include <clipping_planes_vertex>\n              #include <worldpos_vertex>\n              #include <envmap_vertex>\n              #include <lights_lambert_vertex>\n              #include <shadowmap_vertex>\n              #include <fog_vertex>\n\n              // vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\n\t            // gl_Position = projectionMatrix * modelViewPosition;\n          }\n      ",GrassFragmentShader:"\n          uniform vec3 diffuse;\n          uniform vec3 emissive;\n          uniform float opacity;\n          varying vec3 vLightFront;\n          varying vec3 vIndirectFront;\n          #ifdef DOUBLE_SIDED\n              varying vec3 vLightBack;\n              varying vec3 vIndirectBack;\n          #endif\n          #include <common>\n          #include <packing>\n          #include <dithering_pars_fragment>\n          #include <color_pars_fragment>\n          #include <uv_pars_fragment>\n          #include <uv2_pars_fragment>\n          #include <map_pars_fragment>\n          #include <alphamap_pars_fragment>\n          #include <aomap_pars_fragment>\n          #include <lightmap_pars_fragment>\n          #include <emissivemap_pars_fragment>\n          #include <envmap_common_pars_fragment>\n          #include <envmap_pars_fragment>\n          #include <cube_uv_reflection_fragment>\n          #include <bsdfs>\n          #include <lights_pars_begin>\n          #include <fog_pars_fragment>\n          #include <shadowmap_pars_fragment>\n          #include <shadowmask_pars_fragment>\n          #include <specularmap_pars_fragment>\n          #include <logdepthbuf_pars_fragment>\n          #include <clipping_planes_pars_fragment>\n  \n          uniform sampler2D texture1;\n          uniform sampler2D texture2;\n          uniform sampler2D texture3;\n          varying vec3 vUv;\n          varying float texture;\n          \n          void main() {\n              #include <clipping_planes_fragment>\n  \n              vec4 diffuseColor = vec4(0.0,0.0,0.0,0.0);\n\n              if (texture < 0.3) {\n                diffuseColor = texture2D(texture1, 1.6 * vUv.xy + vec2(.51, .51));\n              } else if (texture > 0.7) {\n                diffuseColor = texture2D(texture2, 1.8 * vUv.xy + vec2(.51, .51));\n              } else {\n                diffuseColor = texture2D(texture3, 1.8 * vUv.xy + vec2(.53, .51));\n              }\n  \n              ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n              vec3 totalEmissiveRadiance = emissive;\n              #include <logdepthbuf_fragment>\n              #include <map_fragment>\n              #include <color_fragment>\n              #include <alphamap_fragment>\n              #include <alphatest_fragment>\n              #include <specularmap_fragment>\n              #include <emissivemap_fragment>\n              reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n              #ifdef DOUBLE_SIDED\n                  reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n              #else\n                  reflectedLight.indirectDiffuse += vIndirectFront;\n              #endif\n              #include <lightmap_fragment>\n              reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n              #ifdef DOUBLE_SIDED\n                  reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n              #else\n                  reflectedLight.directDiffuse = vLightFront;\n              #endif\n              reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n              #include <aomap_fragment>\n              vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n              #include <envmap_fragment>\n              gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n              #include <tonemapping_fragment>\n              #include <encodings_fragment>\n              #include <fog_fragment>\n              #include <premultiplied_alpha_fragment>\n              #include <dithering_fragment>\n          }\n      ",LandVertexShader:"\n          #define MYLAND\n          varying vec3 vLightFront;\n          varying vec3 vIndirectFront;\n          #ifdef DOUBLE_SIDED\n              varying vec3 vLightBack;\n              varying vec3 vIndirectBack;\n          #endif\n          #include <common>\n          #include <uv_pars_vertex>\n          #include <uv2_pars_vertex>\n          #include <envmap_pars_vertex>\n          #include <bsdfs>\n          #include <lights_pars_begin>\n          #include <color_pars_vertex>\n          #include <fog_pars_vertex>\n          #include <morphtarget_pars_vertex>\n          #include <skinning_pars_vertex>\n          #include <shadowmap_pars_vertex>\n          #include <logdepthbuf_pars_vertex>\n          #include <clipping_planes_pars_vertex>\n          attribute float tex;\n          varying vec3 vUv;\n          varying float texture;\n          void main() {\n              #include <uv_vertex>\n              #include <uv2_vertex>\n              #include <color_vertex>\n              #include <beginnormal_vertex>\n              #include <morphnormal_vertex>\n              #include <skinbase_vertex>\n              #include <skinnormal_vertex>\n              #include <defaultnormal_vertex>\n              #include <begin_vertex>\n              #include <morphtarget_vertex>\n              #include <skinning_vertex>\n              #include <project_vertex>\n              #include <logdepthbuf_vertex>\n              #include <clipping_planes_vertex>\n              #include <worldpos_vertex>\n              #include <envmap_vertex>\n              #include <lights_lambert_vertex>\n              #include <shadowmap_vertex>\n              #include <fog_vertex>\n  \n              vUv = position;\n              texture = tex;\n          }\n      ",LandFragmentShader:"\n          uniform vec3 diffuse;\n          uniform vec3 emissive;\n          uniform float opacity;\n          varying vec3 vLightFront;\n          varying vec3 vIndirectFront;\n          #ifdef DOUBLE_SIDED\n              varying vec3 vLightBack;\n              varying vec3 vIndirectBack;\n          #endif\n          #include <common>\n          #include <packing>\n          #include <dithering_pars_fragment>\n          #include <color_pars_fragment>\n          #include <uv_pars_fragment>\n          #include <uv2_pars_fragment>\n          #include <map_pars_fragment>\n          #include <alphamap_pars_fragment>\n          #include <aomap_pars_fragment>\n          #include <lightmap_pars_fragment>\n          #include <emissivemap_pars_fragment>\n          #include <envmap_common_pars_fragment>\n          #include <envmap_pars_fragment>\n          #include <cube_uv_reflection_fragment>\n          #include <bsdfs>\n          #include <lights_pars_begin>\n          #include <fog_pars_fragment>\n          #include <shadowmap_pars_fragment>\n          #include <shadowmask_pars_fragment>\n          #include <specularmap_pars_fragment>\n          #include <logdepthbuf_pars_fragment>\n          #include <clipping_planes_pars_fragment>\n\n          uniform sampler2D grassTexture;\n          uniform sampler2D sandTexture;\n          uniform sampler2D gravelTexture;\n          uniform sampler2D snowTexture;\n          varying vec3 vUv;\n          varying float texture;\n  \n          void main() {\n              #include <clipping_planes_fragment>\n\n              vec4 color = vec4(0.0,0.0,0.0,0.0);\n\n              if (texture > 0.0 && texture <= 1.0) {\n                color = mix(color, texture2D(sandTexture, vUv.xz), texture);\n              }\n              if (texture > 1.0 && texture <= 2.0) {\n                color = texture2D(sandTexture, vUv.xz);\n                color = mix(color, texture2D(grassTexture, vUv.xz), texture - 1.0);\n              }\n              if (texture > 2.0 && texture <= 3.0) {\n                color = texture2D(grassTexture, vUv.xz);\n                color = mix(color, texture2D(gravelTexture, vUv.xz), texture - 2.0);\n              }\n              if (texture > 3.0 && texture <= 4.0) {\n                color = texture2D(gravelTexture, vUv.xz);\n                color = mix(color, texture2D(snowTexture, vUv.xz), texture - 3.0);\n              }\n  \n              ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n              vec3 totalEmissiveRadiance = emissive;\n              #include <logdepthbuf_fragment>\n              #include <map_fragment>\n              #include <color_fragment>\n              #include <alphamap_fragment>\n              #include <alphatest_fragment>\n              #include <specularmap_fragment>\n              #include <emissivemap_fragment>\n              reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n              #ifdef DOUBLE_SIDED\n                  reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n              #else\n                  reflectedLight.indirectDiffuse += vIndirectFront;\n              #endif\n              #include <lightmap_fragment>\n              reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( color.rgb );\n              #ifdef DOUBLE_SIDED\n                  reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n              #else\n                  reflectedLight.directDiffuse = vLightFront;\n              #endif\n              reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( color.rgb ) * getShadowMask();\n              #include <aomap_fragment>\n              vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n              #include <envmap_fragment>\n              gl_FragColor = vec4( outgoingLight, color.a );\n              #include <tonemapping_fragment>\n              #include <encodings_fragment>\n              #include <fog_fragment>\n              #include <premultiplied_alpha_fragment>\n              #include <dithering_fragment>\n          }\n      ",WaterVertexShader:"\n          #define MYWATER\n          varying vec3 vViewPosition;\n          #ifndef FLAT_SHADED\n              varying vec3 vNormal;\n          #endif\n          #include <common>\n          #include <uv_pars_vertex>\n          #include <uv2_pars_vertex>\n          #include <displacementmap_pars_vertex>\n          #include <envmap_pars_vertex>\n          #include <color_pars_vertex>\n          #include <fog_pars_vertex>\n          #include <morphtarget_pars_vertex>\n          #include <skinning_pars_vertex>\n          #include <shadowmap_pars_vertex>\n          #include <logdepthbuf_pars_vertex>\n          #include <clipping_planes_pars_vertex>\n  \n          varying vec3 vUv;\n          uniform float time;\n          uniform float amp;\n  \n          void main() {\n              vUv = position; \n              #include <uv_vertex>\n              #include <uv2_vertex>\n              #include <color_vertex>\n              #include <beginnormal_vertex>\n              #include <morphnormal_vertex>\n              #include <skinbase_vertex>\n              #include <skinnormal_vertex>\n              #include <defaultnormal_vertex>\n          #ifndef FLAT_SHADED\n              vNormal = normalize( transformedNormal );\n          #endif\n              #include <begin_vertex>\n              #include <morphtarget_vertex>\n              #include <skinning_vertex>\n              #include <displacementmap_vertex>\n              #include <project_vertex>\n              #include <logdepthbuf_vertex>\n              #include <clipping_planes_vertex>\n              vViewPosition = - mvPosition.xyz;\n              #include <worldpos_vertex>\n              #include <envmap_vertex>\n              #include <shadowmap_vertex>\n              #include <fog_vertex>\n  \n            vNormal = normalMatrix * normal;\n            float freq = 0.3;\n            float angle = ((time * 0.2) + (position.x * 8.0))*freq;\n            vUv.z += sin(angle)*amp;\n            vNormal = normalMatrix * normalize(vec3(-amp * freq * cos(angle),0.0,1.0));\n            vec4 modelViewPosition = modelViewMatrix * vec4(vUv, 1.0);\n            gl_Position = projectionMatrix * modelViewPosition;\n          }\n      ",WaterFragmentShader:"\n          #define MYWATER\n          uniform vec3 diffuse;\n          uniform vec3 emissive;\n          uniform vec3 specular;\n          uniform float shininess;\n          uniform float opacity;\n          #include <common>\n          #include <packing>\n          #include <dithering_pars_fragment>\n          #include <color_pars_fragment>\n          #include <uv_pars_fragment>\n          #include <uv2_pars_fragment>\n          #include <map_pars_fragment>\n          #include <alphamap_pars_fragment>\n          #include <aomap_pars_fragment>\n          #include <lightmap_pars_fragment>\n          #include <emissivemap_pars_fragment>\n          #include <envmap_common_pars_fragment>\n          #include <envmap_pars_fragment>\n          #include <cube_uv_reflection_fragment>\n          #include <fog_pars_fragment>\n          #include <bsdfs>\n          #include <lights_pars_begin>\n          #include <lights_phong_pars_fragment>\n          #include <shadowmap_pars_fragment>\n          #include <bumpmap_pars_fragment>\n          #include <normalmap_pars_fragment>\n          #include <specularmap_pars_fragment>\n          #include <logdepthbuf_pars_fragment>\n          #include <clipping_planes_pars_fragment>\n  \n          varying vec3 vPos;\n          uniform float time;\n          uniform sampler2D texture1;\n              varying vec3 vUv;\n          \n          void main() {\n            #include <clipping_planes_fragment>\n  \n            // Compute the ripple effect.\n            float mod1 = 16.0;\n            float mod2 = 0.4;\n              float xoffset = 0.05 * cos(time / 52.0 + mod1 * vUv.y) + 0.09 * cos(time / 65.0 + mod2 * vUv.y);\n                  float yoffset = 0.02 * cos(time / 35.0 + mod1 * vUv.x) + 0.07 * cos(time / 55.0 + mod2 * vUv.x);\n            vec4 diffuseColor = texture2D(texture1, vec2(vUv.x + xoffset, vUv.y + yoffset));\n            // vec4 diffuseColor = texture2D(texture1, vUv.xy);\n            \n            //vec4 diffuseColor = vec4( diffuse, opacity );\n            ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n            vec3 totalEmissiveRadiance = emissive;\n            #include <logdepthbuf_fragment>\n            #include <map_fragment>\n            #include <color_fragment>\n            #include <alphamap_fragment>\n            #include <alphatest_fragment>\n            #include <specularmap_fragment>\n            #include <normal_fragment_begin>\n            #include <normal_fragment_maps>\n            #include <emissivemap_fragment>\n            #include <lights_phong_fragment>\n            #include <lights_fragment_begin>\n            #include <lights_fragment_maps>\n            #include <lights_fragment_end>\n            #include <aomap_fragment>\n            vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n            #include <envmap_fragment>\n            gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n            #include <tonemapping_fragment>\n            #include <encodings_fragment>\n            #include <fog_fragment>\n            #include <premultiplied_alpha_fragment>\n            #include <dithering_fragment>\n            gl_FragColor.a = 0.95;\n          }\n      "}},function(e,n,t){e.exports=function(){return new Worker(t.p+"worker.js")}},function(e,n,t){"use strict";var i=this&&this.__createBinding||(Object.create?function(e,n,t,i){void 0===i&&(i=t),Object.defineProperty(e,i,{enumerable:!0,get:function(){return n[t]}})}:function(e,n,t,i){void 0===i&&(i=t),e[i]=n[t]}),r=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,"default",{enumerable:!0,value:n})}:function(e,n){e.default=n}),a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)"default"!==t&&Object.hasOwnProperty.call(e,t)&&i(n,e,t);return r(n,e),n};Object.defineProperty(n,"__esModule",{value:!0}),n.MyCamera=void 0;const s=a(t(2)),o=t(3);n.MyCamera=class{constructor(e,n,t){this.speed=new s.Vector2,this.acceleration=50,this.drag=-6.5,this.preferredZoom=1.8,this.toggleMap=function(){this.mapMode=!this.mapMode,this.mapMode?(this.preferredZoom=300,this.camera.rotation.y=0,this.ambientLight.visible=!0):(this.preferredZoom=1.8,this.ambientLight.visible=!1)},this.handleCameraMove=function(e){if(this.mapMode){this.camera.rotation.x>=-1.57&&(this.camera.rotation.x-=8*e,this.camera.rotation.x<-1.57&&(this.camera.rotation.x=-1.57));var n=(i=o.getHeight(this.camera.position.x,this.camera.position.z))+this.preferredZoom-this.camera.position.y;return void(this.camera.position.y+=n*e*5)}this.camera.rotation.x<0&&(this.camera.rotation.x+=1.5*e,this.camera.rotation.x>0&&(this.camera.rotation.x=0));var t=new s.Vector2(0,0),i=o.getHeight(this.camera.position.x,this.camera.position.z);this.controls.KeysPressed.w&&(t.y+=1),this.controls.KeysPressed.s&&(t.y-=1),this.controls.KeysPressed.q&&(t.x-=1),this.controls.KeysPressed.e&&(t.x+=1),this.controls.KeysPressed.a&&(this.camera.rotation.y+=2.5*e),this.controls.KeysPressed.d&&(this.camera.rotation.y-=2.5*e),t.rotateAround(new s.Vector2,this.camera.rotation.y);let r=1;if(this.terrain.isWater(i))i=Math.max(i,3.5),r=3;else{let e=o.getHeight(this.camera.position.x+t.x,this.camera.position.z+t.y),n=Math.abs(e-i);r=Math.min(Math.max(1,3*n),3)}if(t.length()>0&&(t.normalize(),t.multiplyScalar(this.acceleration*e)),this.speed.length()>0){let n=new s.Vector2;n.set(this.speed.x,this.speed.y),n.multiplyScalar(this.drag*e*r),t.add(n)}this.speed.add(t),this.camera.position.x+=this.speed.x*e,this.camera.position.z-=this.speed.y*e;n=i+this.preferredZoom-this.camera.position.y;this.camera.position.y+=n*e*5},this.camera=new s.PerspectiveCamera(75,window.innerWidth/window.innerHeight,.1,2e3),this.camera.position.x=96,this.camera.position.y=1e5,this.camera.position.z=33,this.controls=n,this.terrain=t,e.add(this.camera),this.ambientLight=new s.AmbientLight(6316128,.5),this.ambientLight.visible=!1,this.camera.add(this.ambientLight)}}},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.Controls=void 0;n.Controls=class{constructor(){this.KeysPressed={w:!1,a:!1,s:!1,d:!1,q:!1,e:!1,f:!1,m:!1};let e=this.KeysPressed,n=this;window.onblur=function(){e.w=e.a=e.s=e.d=!1},window.onkeydown=function(t){switch(t.keyCode){case 87:case 38:e.w=!0;break;case 65:case 37:e.a=!0;break;case 83:case 40:e.s=!0;break;case 68:case 39:e.d=!0;break;case 81:e.q=!0;break;case 69:e.e=!0;break;case 70:e.f=!0,n.flashLight=!n.flashLight;break;case 77:e.m=!0,n.camera&&n.camera.toggleMap();break;default:return!0}return!1},window.onkeyup=function(n){switch(n.keyCode){case 87:case 38:e.w=!1;break;case 65:case 37:e.a=!1;break;case 83:case 40:e.s=!1;break;case 68:case 39:e.d=!1;break;case 81:e.q=!1;break;case 69:e.e=!1;break;case 70:e.f=!1;break;case 77:e.m=!0;break;default:return!0}return!1},window.onwheel=function(e){n.camera&&-1.57==n.camera.camera.rotation.x&&(n.camera.preferredZoom-=.01*e.deltaY,n.camera.preferredZoom<1&&(n.camera.preferredZoom=1),n.camera.preferredZoom>1800&&(n.camera.preferredZoom=1800))}}}}]);
//# sourceMappingURL=bundle.js.map