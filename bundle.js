!function(e){var n={};function t(r){if(n[r])return n[r].exports;var i=n[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,t),i.l=!0,i.exports}t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var i in e)t.d(r,i,function(n){return e[n]}.bind(null,i));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=1)}([function(e,n){e.exports=THREE},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),t(2);const r=t(0),i=t(6),a=t(8),o=t(9),s=new r.Scene;let c=new i.Terrain(s,3);const l=new o.Controls,u=new a.MyCamera(s,l,c);l.camera=u;const d=new r.WebGLRenderer({antialias:!1});d.setSize(window.innerWidth,window.innerHeight);let f=new r.Color(6658234),p=new r.Color(6216);s.background=new r.Color(0,0,0),document.body.appendChild(d.domElement);let m=new r.SpotLight(16777181,.6,100,.8,.5,1);u.camera.add(m),m.position.set(0,0,3),m.target=u.camera;let g=new r.Group;s.add(g);let h=new r.DirectionalLight(15654365,.5);h.position.y=1e3,h.position.z=1e3,h.target=u.camera,g.add(h);var v=(new r.TextureLoader).load("img/sun.png"),_=new r.SpriteMaterial({map:v}),x=new r.Sprite(_);x.scale.multiplyScalar(500),g.add(x),x.position.copy(h.position);var y=(new r.TextureLoader).load("img/moon.png"),w=new r.SpriteMaterial({map:y}),b=new r.Sprite(w);b.scale.multiplyScalar(50),b.position.y=-500,b.position.z=-250,g.add(b);const M=1e5*Math.PI*2;let k=0;var L=0,S=0;let D=0,C=0;!function e(){requestAnimationFrame(e),function(){D=Date.now();let e=Math.min((D-C)/1e3,1);C=D,function(){let e=D/-1e5;g.rotation.z=e,g.position.x=u.camera.position.x,g.position.z=u.camera.position.z,g.position.y=100,k=D%M*24/M,k+=12,k>24&&(k-=24),l.flashLight?m.intensity=.6:m.intensity=0;let n=new r.Vector3;h.getWorldPosition(n);let t=0;t=Math.min((n.y+200)/1e3,1),s.background.setRGB(t*f.r+p.r,t*f.g+p.g,t*f.b+p.b)}(),function(){if(20==++L){var e=document.getElementById("fps"),n=document.getElementById("posX"),t=document.getElementById("posY"),r=document.getElementById("calls"),i=document.getElementById("speed"),a=document.getElementById("time");if(e){var o=1e3/((D-S)/20);e.innerText=Math.round(o).toString(),n.innerText=u.camera.position.x.toFixed(2),t.innerText=u.camera.position.z.toFixed(2)+" z:"+u.camera.position.y.toFixed(2),r.innerText=d.info.render.calls.toString(),i.innerText=u.speed.length().toFixed(2).toString(),a.innerText=(k<10?"0":"")+Math.floor(k)+":"+(Math.floor(k%1*60)<10?"0":"")+Math.floor(k%1*60),S=D,L=0}}}(),c.updateChunks(e,u.camera),u.handleCameraMove(e),d.render(s,u.camera)}()}(),window.onresize=function(){u.camera.aspect=window.innerWidth/window.innerHeight,u.camera.updateProjectionMatrix(),d.setSize(window.innerWidth,window.innerHeight)}},function(e,n,t){var r=t(3),i=t(4);"string"==typeof(i=i.__esModule?i.default:i)&&(i=[[e.i,i,""]]);var a={insert:"head",singleton:!1};r(i,a);e.exports=i.locals||{}},function(e,n,t){"use strict";var r,i=function(){return void 0===r&&(r=Boolean(window&&document&&document.all&&!window.atob)),r},a=function(){var e={};return function(n){if(void 0===e[n]){var t=document.querySelector(n);if(window.HTMLIFrameElement&&t instanceof window.HTMLIFrameElement)try{t=t.contentDocument.head}catch(e){t=null}e[n]=t}return e[n]}}(),o=[];function s(e){for(var n=-1,t=0;t<o.length;t++)if(o[t].identifier===e){n=t;break}return n}function c(e,n){for(var t={},r=[],i=0;i<e.length;i++){var a=e[i],c=n.base?a[0]+n.base:a[0],l=t[c]||0,u="".concat(c," ").concat(l);t[c]=l+1;var d=s(u),f={css:a[1],media:a[2],sourceMap:a[3]};-1!==d?(o[d].references++,o[d].updater(f)):o.push({identifier:u,updater:h(f,n),references:1}),r.push(u)}return r}function l(e){var n=document.createElement("style"),r=e.attributes||{};if(void 0===r.nonce){var i=t.nc;i&&(r.nonce=i)}if(Object.keys(r).forEach((function(e){n.setAttribute(e,r[e])})),"function"==typeof e.insert)e.insert(n);else{var o=a(e.insert||"head");if(!o)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");o.appendChild(n)}return n}var u,d=(u=[],function(e,n){return u[e]=n,u.filter(Boolean).join("\n")});function f(e,n,t,r){var i=t?"":r.media?"@media ".concat(r.media," {").concat(r.css,"}"):r.css;if(e.styleSheet)e.styleSheet.cssText=d(n,i);else{var a=document.createTextNode(i),o=e.childNodes;o[n]&&e.removeChild(o[n]),o.length?e.insertBefore(a,o[n]):e.appendChild(a)}}function p(e,n,t){var r=t.css,i=t.media,a=t.sourceMap;if(i?e.setAttribute("media",i):e.removeAttribute("media"),a&&btoa&&(r+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(a))))," */")),e.styleSheet)e.styleSheet.cssText=r;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(r))}}var m=null,g=0;function h(e,n){var t,r,i;if(n.singleton){var a=g++;t=m||(m=l(n)),r=f.bind(null,t,a,!1),i=f.bind(null,t,a,!0)}else t=l(n),r=p.bind(null,t,n),i=function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)};return r(e),function(n){if(n){if(n.css===e.css&&n.media===e.media&&n.sourceMap===e.sourceMap)return;r(e=n)}else i()}}e.exports=function(e,n){(n=n||{}).singleton||"boolean"==typeof n.singleton||(n.singleton=i());var t=c(e=e||[],n);return function(e){if(e=e||[],"[object Array]"===Object.prototype.toString.call(e)){for(var r=0;r<t.length;r++){var i=s(t[r]);o[i].references--}for(var a=c(e,n),l=0;l<t.length;l++){var u=s(t[l]);0===o[u].references&&(o[u].updater(),o.splice(u,1))}t=a}}}},function(e,n,t){(n=t(5)(!1)).push([e.i,"/* Styles go here. */\r\n\r\nhtml,\r\nbody {\r\n  margin: 0;\r\n  padding: 0;\r\n  font-family: Arial, Helvetica, sans-serif;\r\n}\r\n\r\ncanvas {\r\n  display: block;\r\n}",""]),e.exports=n},function(e,n,t){"use strict";e.exports=function(e){var n=[];return n.toString=function(){return this.map((function(n){var t=function(e,n){var t=e[1]||"",r=e[3];if(!r)return t;if(n&&"function"==typeof btoa){var i=(o=r,s=btoa(unescape(encodeURIComponent(JSON.stringify(o)))),c="sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(s),"/*# ".concat(c," */")),a=r.sources.map((function(e){return"/*# sourceURL=".concat(r.sourceRoot||"").concat(e," */")}));return[t].concat(a).concat([i]).join("\n")}var o,s,c;return[t].join("\n")}(n,e);return n[2]?"@media ".concat(n[2]," {").concat(t,"}"):t})).join("")},n.i=function(e,t,r){"string"==typeof e&&(e=[[null,e,""]]);var i={};if(r)for(var a=0;a<this.length;a++){var o=this[a][0];null!=o&&(i[o]=!0)}for(var s=0;s<e.length;s++){var c=[].concat(e[s]);r&&i[c[0]]||(t&&(c[2]?c[2]="".concat(t," and ").concat(c[2]):c[2]=t),n.push(c))}},n}},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.Terrain=void 0;const r=t(0),i=t(7),a=4.3,o=5,s=4,c=25;var l=c-(s+(c-s)/4);const u=64,d=64;noise.seed(1024);const f=(new r.TextureLoader).load("img/grass.png"),p=(new r.TextureLoader).load("img/grassblade.png"),m=(new r.TextureLoader).load("img/grassblade2.png"),g=(new r.TextureLoader).load("img/grassblade3.png"),h=(new r.TextureLoader).load("img/horse-chestnut-tree.png"),v=(new r.TextureLoader).load("img/gravel.png"),_=(new r.TextureLoader).load("img/sand.png"),x=(new r.TextureLoader).load("img/water.png"),y=(new r.TextureLoader).load("img/snow.png");x.wrapS=r.MirroredRepeatWrapping,x.wrapT=r.MirroredRepeatWrapping,v.wrapS=y.wrapS=_.wrapS=f.wrapS=r.RepeatWrapping,v.wrapT=y.wrapT=_.wrapT=f.wrapT=r.RepeatWrapping,h.magFilter=p.magFilter=v.magFilter=y.magFilter=_.magFilter=f.magFilter=r.NearestFilter;const w=r.UniformsUtils.merge([r.ShaderLib.phong.uniforms]);w.texture1={type:"t",value:x},w.time={type:"f",value:1},w.amp={type:"f",value:.004};const b=new r.ShaderMaterial({uniforms:w,vertexShader:i.MyShaders.WaterVertexShader,fragmentShader:i.MyShaders.WaterFragmentShader,lights:!0}),M=r.UniformsUtils.merge([r.ShaderLib.standard.uniforms]);M.grassTexture={type:"t",value:f},M.sandTexture={type:"t",value:_},M.snowTexture={type:"t",value:y},M.gravelTexture={type:"t",value:v};const k=r.UniformsUtils.merge([r.ShaderLib.standard.uniforms]);function L(){let e=new r.PlaneBufferGeometry(.5,.5);return new r.InstancedMesh(e,new r.ShaderMaterial({uniforms:k,side:r.DoubleSide,vertexShader:i.MyShaders.GrassVertexShader,fragmentShader:i.MyShaders.GrassFragmentShader,transparent:!0,alphaTest:.5,lights:!0}),u*d*.5)}k.texture1={type:"t",value:p},k.texture2={type:"t",value:m},k.texture3={type:"t",value:g},k.textureTree={type:"t",value:h},k.time={type:"f",value:0},k.amp={type:"f",value:.5},k.roughness.value=1;const S=new r.ShaderMaterial({uniforms:M,vertexShader:i.MyShaders.LandVertexShader,fragmentShader:i.MyShaders.LandFragmentShader,lights:!0,side:r.BackSide});var D=new r.PlaneBufferGeometry(320,320,480,1),C=new r.Mesh(D,b);C.position.y=a+.55,C.rotation.x=-.5*Math.PI;var F=new r.PlaneBufferGeometry(6400,6400,1,1),T=new r.Mesh(F,new r.MeshPhongMaterial({map:x}));T.position.y=a+.5,T.rotation.x=-.5*Math.PI;class P{constructor(e,n){this.x=e,this.y=n,this.geo=new r.PlaneBufferGeometry(u,d,u,d),this.planeMesh=new r.Mesh(this.geo,S),this.discarded=!1}}n.Terrain=class{constructor(e,n){this.chunkRange=1,this.chunks=[],this.chunkMap=[],this.discardedChunks=[],this.destroyGrass=function(e){e.material.dispose(),e.geometry.dispose(),this.grassGroup.remove(e)},this.lastCubeCenter={x:1,y:1},this.chunkRange=n,this.group=new r.Group,e.add(this.group),this.waterGroup=new r.Group,this.waterGroup.add(T),this.waterGroup.add(C),this.group.add(this.waterGroup),this.terrainGroup=new r.Group,this.group.add(this.terrainGroup),this.grassGroup=new r.Group,this.group.add(this.grassGroup),this.terrainWorker=new Worker("js/terrainworker.js");let t=this;this.terrainWorker.onmessage=function(e){t.processChunk(e.data[0],e.data[1],e.data[2],e.data[3],e.data[4],e.data[5])}}getHeight(e,n){var t=25*noise.simplex2(e/100,n/100)+25+1.5*noise.simplex2(e/8,n/8)+30*noise.simplex2(e/1200,n/1200)+5,r=s+(t-s)/4;return t>c?Math.pow(r,1.4)-13.5:r}getLandTexture(e,n,t){if(t<a)return 0;if(t<o+.5)return 1;if(t<o+1)return 1+2*(t-(o+.5));let r=3+3*noise.simplex2(e/20,n/20);if(t>c+3+r)return 4;if(t>c+2+r)return t-(c+2+r)+3;let i=5+5*noise.simplex2(e/15,n/15);return t>l+i?3:t>l+i-1?t-(l+i-1)+2:2}isWater(e){return e<a+.55}createChunkObject(e,n){if(this.discardedChunks.length>0){let t=this.discardedChunks.pop();return t.x=e,t.y=n,t.discarded=!1,t.processed=!1,t.grassMesh=L(),t}let t=new P(e,n);return t.grassMesh=L(),this.terrainGroup.add(t.planeMesh),t.processed=!1,t}fixChunkNormals(e){e.geo.computeBoundingSphere(),e.geo.computeVertexNormals();let n,t,r,i=u+1,a=d+1,o=e.geo.getAttribute("normal");if(this.chunkMap[e.x-u]&&this.chunkMap[e.x-u][e.y]&&(n=this.chunkMap[e.x-u][e.y],n.processed)){t=n.geo.getAttribute("normal");for(let e=0;e<a;e++)r=(i-1)*a+e,o.setXYZ(e,t.getX(r),t.getY(r),t.getZ(r))}if(this.chunkMap[e.x+u]&&this.chunkMap[e.x+u][e.y]&&(n=this.chunkMap[e.x+u][e.y],n.processed)){t=n.geo.getAttribute("normal");for(let e=0;e<a;e++)r=e,o.setXYZ((i-1)*a+e,t.getX(r),t.getY(r),t.getZ(r))}if(this.chunkMap[e.x]&&this.chunkMap[e.x][e.y+d]&&(n=this.chunkMap[e.x][e.y+d],n.processed)){t=n.geo.getAttribute("normal");for(let e=0;e<i;e++)r=e*a,o.setXYZ(e*a+(i-1),t.getX(r),t.getY(r),t.getZ(r))}if(this.chunkMap[e.x]&&this.chunkMap[e.x][e.y-d]&&(n=this.chunkMap[e.x][e.y-d],n.processed)){t=n.geo.getAttribute("normal");for(let e=0;e<i;e++)r=e*a+(i-1),o.setXYZ(e*a,t.getX(r),t.getY(r),t.getZ(r))}e.geo.getAttribute("position").needsUpdate=!0}processChunk(e,n,t,i,a,o){let s=this.chunkMap[e][n];s.geo.setAttribute("position",new r.BufferAttribute(new Float32Array(t),3,!0)),s.geo.setAttribute("tex",new r.BufferAttribute(new Float32Array(i),1,!1)),s.grassMesh.count=o.length,s.grassMesh.instanceMatrix.copyArray(a),s.grassMesh.geometry.setAttribute("tex",new r.InstancedBufferAttribute(new Float32Array(o),1,!1,1)),s.grassMesh.geometry.getAttribute("position").needsUpdate=!0,s.grassMesh.geometry.getAttribute("tex").needsUpdate=!0,this.fixChunkNormals(s),this.grassGroup.add(s.grassMesh),s.processed=!0}createChunk2(e,n){let t=this.createChunkObject(e,n);this.terrainWorker.postMessage([e,n]),this.chunks.push(t),this.chunkMap[e]||(this.chunkMap[e]=[]),this.chunkMap[e][n]=t}createChunk(e,n){let t=this.createChunkObject(e,n),i=t.geo.getAttribute("position").array,a=u+1,s=d+1;const c=new r.BufferAttribute(new Float32Array(a*s),1,!1);let l=new r.Matrix4,f=new r.Vector3,p=new r.Euler,m=new r.Quaternion,g=new r.Vector3(1,1,1);const h=new r.InstancedBufferAttribute(new Float32Array(t.grassMesh.count),1,!1,1);let v=0,_=0;for(let r=0;r<a;r++)for(let a=0;a<s;a++){let x=r-u/2+e,y=a-d/2+n;i[3*(r*s+a)]=x,i[3*(r*s+a)+2]=y;let w=this.getHeight(x,y);i[3*(r*s+a)+1]=w,c.setX(r*s+a,this.getLandTexture(x,y,w)),0!=a&&0!=r&&w>o+1&&w<o+8&&(noise.simplex2(x/5,y/5)>.5&&(g.set(1,1,1),f.x=x,f.z=y,f.y=w+.25,p.y=Math.random()*Math.PI*2,m.setFromEuler(p),l.compose(f,m,g),t.grassMesh.setMatrixAt(_++,l),h.setX(v++,Math.random())),noise.simplex2(x/7,y/7)*noise.simplex2(x/1,y/1)>.8&&(g.set(10,10,10),f.x=x,f.z=y,f.y=w+2,p.y=Math.random()*Math.PI*2,m.setFromEuler(p),l.compose(f,m,g),t.grassMesh.setMatrixAt(_++,l),p.y+=.5*Math.PI,m.setFromEuler(p),l.compose(f,m,g),t.grassMesh.setMatrixAt(_++,l),h.setX(v++,10),h.setX(v++,10)))}this.fixChunkNormals(t),this.chunks.push(t),t.planeMesh.geometry.setAttribute("tex",c),this.chunkMap[e]||(this.chunkMap[e]=[]),t.grassMesh.geometry.setAttribute("tex",h),this.chunkMap[e][n]=t,this.grassGroup.add(t.grassMesh)}destroyChunk(e){e.discarded=!0,this.discardedChunks.push(e),delete this.chunkMap[e.x][e.y],0==Object.keys(this.chunkMap[e.x]).length&&delete this.chunkMap[e.x],this.destroyGrass(e.grassMesh)}updateChunks(e,n){w.time.value+=60*e,k.time.value+=60*e;let t=Math.round(n.position.x),r=Math.round(n.position.z);if((Math.abs(t-this.waterGroup.position.x)>128||Math.abs(r-this.waterGroup.position.z)>128)&&(this.waterGroup.position.x=t,this.waterGroup.position.z=r),this.lastCubeCenter.x==t&&this.lastCubeCenter.y==r)return;let i=Math.round(t/u)*u,a=Math.round(r/d)*d;var o=i-this.chunkRange*u,s=i+this.chunkRange*u,c=a-this.chunkRange*d;let l=a+this.chunkRange*d;for(var f=0;f<this.chunks.length;f++)if(this.chunks[f].x<o||this.chunks[f].x>s||this.chunks[f].y<c||this.chunks[f].y>l)return this.destroyChunk(this.chunks[f]),void this.chunks.splice(f,1);for(f=-this.chunkRange;f<=this.chunkRange;f++)for(var p=i+f*u,m=-this.chunkRange;m<=this.chunkRange;m++){var g=a+m*d;if(!this.chunkMap[p]||!this.chunkMap[p][g])return void this.createChunk2(p,g);this.chunkMap[p][g].grassMesh.visible=Math.abs(p-t)<1.5*u&&Math.abs(g-r)<1.5*d}this.lastCubeCenter.x=t,this.lastCubeCenter.y=r}}},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.MyShaders=void 0,n.MyShaders={GrassVertexShader:"\n          #define MYLAND\n          varying vec3 vLightFront;\n          varying vec3 vIndirectFront;\n          #ifdef DOUBLE_SIDED\n              varying vec3 vLightBack;\n              varying vec3 vIndirectBack;\n          #endif\n          #include <common>\n          #include <uv_pars_vertex>\n          #include <uv2_pars_vertex>\n          #include <envmap_pars_vertex>\n          #include <bsdfs>\n          #include <lights_pars_begin>\n          #include <color_pars_vertex>\n          #include <fog_pars_vertex>\n          #include <morphtarget_pars_vertex>\n          #include <skinning_pars_vertex>\n          #include <shadowmap_pars_vertex>\n          #include <logdepthbuf_pars_vertex>\n          #include <clipping_planes_pars_vertex>\n\n          varying vec3 vUv;\n          attribute float tex;\n          varying float texture;\n          uniform float time;\n          uniform float amp;\n\n          void main() {\n\n              vUv = position;\n              texture = tex;\n\n              \n           \n              #include <uv_vertex>\n              #include <uv2_vertex>\n              #include <color_vertex>\n              #include <beginnormal_vertex>\n              #include <morphnormal_vertex>\n              #include <skinbase_vertex>\n              #include <skinnormal_vertex>\n              #include <defaultnormal_vertex>\n              #include <begin_vertex>\n              #include <morphtarget_vertex>\n              #include <skinning_vertex>\n              \n              vec4 mvPosition = vec4( transformed, 1.0 );\n              if (position.y > 0.0 && tex < 9.0) {\n                float freq = 0.2 * min(max(instanceMatrix[0].x, 0.7), 1.8);\n                float angle = ((time * 0.2) + (position.y * 8.0)) * freq;\n                angle += instanceMatrix[3].x;\n                mvPosition.z += cos(angle) * amp * freq;\n              }\n              if (position.y > 0.0 && tex > 9.0) {\n                float freq = 0.1;\n                float angle = (time * 0.2) * freq;\n                if (position.x > 0.0) {\n                  mvPosition.z += cos(angle) * amp * freq * 0.5;\n                } else {\n                  mvPosition.z -= cos(angle) * amp * freq * 0.5;\n                }\n              }\n\n              #ifdef USE_INSTANCING\n                mvPosition = instanceMatrix * mvPosition;\n              #endif\n\n              mvPosition = modelViewMatrix * mvPosition;              \n              gl_Position = projectionMatrix * mvPosition;\n              #include <logdepthbuf_vertex>\n              #include <clipping_planes_vertex>\n              #include <worldpos_vertex>\n              #include <envmap_vertex>\n              #include <lights_lambert_vertex>\n              #include <shadowmap_vertex>\n              #include <fog_vertex>\n\n              // vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\n\t            // gl_Position = projectionMatrix * modelViewPosition;\n          }\n      ",GrassFragmentShader:"\n          uniform vec3 diffuse;\n          uniform vec3 emissive;\n          uniform float opacity;\n          varying vec3 vLightFront;\n          varying vec3 vIndirectFront;\n          #ifdef DOUBLE_SIDED\n              varying vec3 vLightBack;\n              varying vec3 vIndirectBack;\n          #endif\n          #include <common>\n          #include <packing>\n          #include <dithering_pars_fragment>\n          #include <color_pars_fragment>\n          #include <uv_pars_fragment>\n          #include <uv2_pars_fragment>\n          #include <map_pars_fragment>\n          #include <alphamap_pars_fragment>\n          #include <aomap_pars_fragment>\n          #include <lightmap_pars_fragment>\n          #include <emissivemap_pars_fragment>\n          #include <envmap_common_pars_fragment>\n          #include <envmap_pars_fragment>\n          #include <cube_uv_reflection_fragment>\n          #include <bsdfs>\n          #include <lights_pars_begin>\n          #include <fog_pars_fragment>\n          #include <shadowmap_pars_fragment>\n          #include <shadowmask_pars_fragment>\n          #include <specularmap_pars_fragment>\n          #include <logdepthbuf_pars_fragment>\n          #include <clipping_planes_pars_fragment>\n  \n          uniform sampler2D texture1;\n          uniform sampler2D texture2;\n          uniform sampler2D texture3;\n          uniform sampler2D textureTree;\n          varying vec3 vUv;\n          varying float texture;\n          \n          void main() {\n              #include <clipping_planes_fragment>\n  \n              vec4 diffuseColor = vec4(0.0,0.0,0.0,0.0);\n\n              if (texture > 1.0) {\n                diffuseColor = texture2D(textureTree, 2.1 * vUv.xy + vec2(.49, .45));\n              } else {\n                if (texture < 0.3) {\n                  diffuseColor = texture2D(texture1, 1.6 * vUv.xy + vec2(.51, .51));\n                } else if (texture > 0.7) {\n                  diffuseColor = texture2D(texture2, 1.8 * vUv.xy + vec2(.51, .51));\n                } else {\n                  diffuseColor = texture2D(texture3, 1.8 * vUv.xy + vec2(.53, .51));\n                }\n              }\n  \n              ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n              vec3 totalEmissiveRadiance = emissive;\n              #include <logdepthbuf_fragment>\n              #include <map_fragment>\n              #include <color_fragment>\n              #include <alphamap_fragment>\n              #include <alphatest_fragment>\n              #include <specularmap_fragment>\n              #include <emissivemap_fragment>\n              reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n              #ifdef DOUBLE_SIDED\n                  reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n              #else\n                  reflectedLight.indirectDiffuse += vIndirectFront;\n              #endif\n              #include <lightmap_fragment>\n              reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n              #ifdef DOUBLE_SIDED\n                  reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n              #else\n                  reflectedLight.directDiffuse = vLightFront;\n              #endif\n              reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n              #include <aomap_fragment>\n              vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n              #include <envmap_fragment>\n              gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n              #include <tonemapping_fragment>\n              #include <encodings_fragment>\n              #include <fog_fragment>\n              #include <premultiplied_alpha_fragment>\n              #include <dithering_fragment>\n          }\n      ",LandVertexShader:"\n          #define MYLAND\n          varying vec3 vLightFront;\n          varying vec3 vIndirectFront;\n          #ifdef DOUBLE_SIDED\n              varying vec3 vLightBack;\n              varying vec3 vIndirectBack;\n          #endif\n          #include <common>\n          #include <uv_pars_vertex>\n          #include <uv2_pars_vertex>\n          #include <envmap_pars_vertex>\n          #include <bsdfs>\n          #include <lights_pars_begin>\n          #include <color_pars_vertex>\n          #include <fog_pars_vertex>\n          #include <morphtarget_pars_vertex>\n          #include <skinning_pars_vertex>\n          #include <shadowmap_pars_vertex>\n          #include <logdepthbuf_pars_vertex>\n          #include <clipping_planes_pars_vertex>\n          attribute float tex;\n          varying vec3 vUv;\n          varying float texture;\n          void main() {\n              #include <uv_vertex>\n              #include <uv2_vertex>\n              #include <color_vertex>\n              #include <beginnormal_vertex>\n              #include <morphnormal_vertex>\n              #include <skinbase_vertex>\n              #include <skinnormal_vertex>\n              #include <defaultnormal_vertex>\n              #include <begin_vertex>\n              #include <morphtarget_vertex>\n              #include <skinning_vertex>\n              #include <project_vertex>\n              #include <logdepthbuf_vertex>\n              #include <clipping_planes_vertex>\n              #include <worldpos_vertex>\n              #include <envmap_vertex>\n              #include <lights_lambert_vertex>\n              #include <shadowmap_vertex>\n              #include <fog_vertex>\n  \n              vUv = position;\n              texture = tex;\n          }\n      ",LandFragmentShader:"\n          uniform vec3 diffuse;\n          uniform vec3 emissive;\n          uniform float opacity;\n          varying vec3 vLightFront;\n          varying vec3 vIndirectFront;\n          #ifdef DOUBLE_SIDED\n              varying vec3 vLightBack;\n              varying vec3 vIndirectBack;\n          #endif\n          #include <common>\n          #include <packing>\n          #include <dithering_pars_fragment>\n          #include <color_pars_fragment>\n          #include <uv_pars_fragment>\n          #include <uv2_pars_fragment>\n          #include <map_pars_fragment>\n          #include <alphamap_pars_fragment>\n          #include <aomap_pars_fragment>\n          #include <lightmap_pars_fragment>\n          #include <emissivemap_pars_fragment>\n          #include <envmap_common_pars_fragment>\n          #include <envmap_pars_fragment>\n          #include <cube_uv_reflection_fragment>\n          #include <bsdfs>\n          #include <lights_pars_begin>\n          #include <fog_pars_fragment>\n          #include <shadowmap_pars_fragment>\n          #include <shadowmask_pars_fragment>\n          #include <specularmap_pars_fragment>\n          #include <logdepthbuf_pars_fragment>\n          #include <clipping_planes_pars_fragment>\n\n          uniform sampler2D grassTexture;\n          uniform sampler2D sandTexture;\n          uniform sampler2D gravelTexture;\n          uniform sampler2D snowTexture;\n          varying vec3 vUv;\n          varying float texture;\n  \n          void main() {\n              #include <clipping_planes_fragment>\n\n              vec4 color = vec4(0.0,0.0,0.0,0.0);\n\n              if (texture > 0.0 && texture <= 1.0) {\n                color = mix(color, texture2D(sandTexture, vUv.xz), texture);\n              }\n              if (texture > 1.0 && texture <= 2.0) {\n                color = texture2D(sandTexture, vUv.xz);\n                color = mix(color, texture2D(grassTexture, vUv.xz), texture - 1.0);\n              }\n              if (texture > 2.0 && texture <= 3.0) {\n                color = texture2D(grassTexture, vUv.xz);\n                color = mix(color, texture2D(gravelTexture, vUv.xz), texture - 2.0);\n              }\n              if (texture > 3.0 && texture <= 4.0) {\n                color = texture2D(gravelTexture, vUv.xz);\n                color = mix(color, texture2D(snowTexture, vUv.xz), texture - 3.0);\n              }\n  \n              ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n              vec3 totalEmissiveRadiance = emissive;\n              #include <logdepthbuf_fragment>\n              #include <map_fragment>\n              #include <color_fragment>\n              #include <alphamap_fragment>\n              #include <alphatest_fragment>\n              #include <specularmap_fragment>\n              #include <emissivemap_fragment>\n              reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n              #ifdef DOUBLE_SIDED\n                  reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n              #else\n                  reflectedLight.indirectDiffuse += vIndirectFront;\n              #endif\n              #include <lightmap_fragment>\n              reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( color.rgb );\n              #ifdef DOUBLE_SIDED\n                  reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n              #else\n                  reflectedLight.directDiffuse = vLightFront;\n              #endif\n              reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( color.rgb ) * getShadowMask();\n              #include <aomap_fragment>\n              vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n              #include <envmap_fragment>\n              gl_FragColor = vec4( outgoingLight, color.a );\n              #include <tonemapping_fragment>\n              #include <encodings_fragment>\n              #include <fog_fragment>\n              #include <premultiplied_alpha_fragment>\n              #include <dithering_fragment>\n          }\n      ",WaterVertexShader:"\n          #define MYWATER\n          varying vec3 vViewPosition;\n          #ifndef FLAT_SHADED\n              varying vec3 vNormal;\n          #endif\n          #include <common>\n          #include <uv_pars_vertex>\n          #include <uv2_pars_vertex>\n          #include <displacementmap_pars_vertex>\n          #include <envmap_pars_vertex>\n          #include <color_pars_vertex>\n          #include <fog_pars_vertex>\n          #include <morphtarget_pars_vertex>\n          #include <skinning_pars_vertex>\n          #include <shadowmap_pars_vertex>\n          #include <logdepthbuf_pars_vertex>\n          #include <clipping_planes_pars_vertex>\n  \n          varying vec3 vUv;\n          uniform float time;\n          uniform float amp;\n  \n          void main() {\n              vUv = position; \n              #include <uv_vertex>\n              #include <uv2_vertex>\n              #include <color_vertex>\n              #include <beginnormal_vertex>\n              #include <morphnormal_vertex>\n              #include <skinbase_vertex>\n              #include <skinnormal_vertex>\n              #include <defaultnormal_vertex>\n          #ifndef FLAT_SHADED\n              vNormal = normalize( transformedNormal );\n          #endif\n              #include <begin_vertex>\n              #include <morphtarget_vertex>\n              #include <skinning_vertex>\n              #include <displacementmap_vertex>\n              #include <project_vertex>\n              #include <logdepthbuf_vertex>\n              #include <clipping_planes_vertex>\n              vViewPosition = - mvPosition.xyz;\n              #include <worldpos_vertex>\n              #include <envmap_vertex>\n              #include <shadowmap_vertex>\n              #include <fog_vertex>\n  \n            vNormal = normalMatrix * normal;\n            float freq = 0.3;\n            float angle = ((time * 0.2) + (position.x * 8.0))*freq;\n            vUv.z += sin(angle)*amp;\n            vNormal = normalMatrix * normalize(vec3(-amp * freq * cos(angle),0.0,1.0));\n            vec4 modelViewPosition = modelViewMatrix * vec4(vUv, 1.0);\n            gl_Position = projectionMatrix * modelViewPosition;\n          }\n      ",WaterFragmentShader:"\n          #define MYWATER\n          uniform vec3 diffuse;\n          uniform vec3 emissive;\n          uniform vec3 specular;\n          uniform float shininess;\n          uniform float opacity;\n          #include <common>\n          #include <packing>\n          #include <dithering_pars_fragment>\n          #include <color_pars_fragment>\n          #include <uv_pars_fragment>\n          #include <uv2_pars_fragment>\n          #include <map_pars_fragment>\n          #include <alphamap_pars_fragment>\n          #include <aomap_pars_fragment>\n          #include <lightmap_pars_fragment>\n          #include <emissivemap_pars_fragment>\n          #include <envmap_common_pars_fragment>\n          #include <envmap_pars_fragment>\n          #include <cube_uv_reflection_fragment>\n          #include <fog_pars_fragment>\n          #include <bsdfs>\n          #include <lights_pars_begin>\n          #include <lights_phong_pars_fragment>\n          #include <shadowmap_pars_fragment>\n          #include <bumpmap_pars_fragment>\n          #include <normalmap_pars_fragment>\n          #include <specularmap_pars_fragment>\n          #include <logdepthbuf_pars_fragment>\n          #include <clipping_planes_pars_fragment>\n  \n          varying vec3 vPos;\n          uniform float time;\n          uniform sampler2D texture1;\n              varying vec3 vUv;\n          \n          void main() {\n            #include <clipping_planes_fragment>\n  \n            // Compute the ripple effect.\n            float mod1 = 16.0;\n            float mod2 = 0.4;\n              float xoffset = 0.05 * cos(time / 52.0 + mod1 * vUv.y) + 0.09 * cos(time / 65.0 + mod2 * vUv.y);\n                  float yoffset = 0.02 * cos(time / 35.0 + mod1 * vUv.x) + 0.07 * cos(time / 55.0 + mod2 * vUv.x);\n            vec4 diffuseColor = texture2D(texture1, vec2(vUv.x + xoffset, vUv.y + yoffset));\n            // vec4 diffuseColor = texture2D(texture1, vUv.xy);\n            \n            //vec4 diffuseColor = vec4( diffuse, opacity );\n            ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n            vec3 totalEmissiveRadiance = emissive;\n            #include <logdepthbuf_fragment>\n            #include <map_fragment>\n            #include <color_fragment>\n            #include <alphamap_fragment>\n            #include <alphatest_fragment>\n            #include <specularmap_fragment>\n            #include <normal_fragment_begin>\n            #include <normal_fragment_maps>\n            #include <emissivemap_fragment>\n            #include <lights_phong_fragment>\n            #include <lights_fragment_begin>\n            #include <lights_fragment_maps>\n            #include <lights_fragment_end>\n            #include <aomap_fragment>\n            vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n            #include <envmap_fragment>\n            gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n            #include <tonemapping_fragment>\n            #include <encodings_fragment>\n            #include <fog_fragment>\n            #include <premultiplied_alpha_fragment>\n            #include <dithering_fragment>\n            gl_FragColor.a = 0.95;\n          }\n      "}},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.MyCamera=void 0;const r=t(0);n.MyCamera=class{constructor(e,n,t){this.speed=new r.Vector2,this.acceleration=50,this.drag=-6.5,this.preferredZoom=1.8,this.handleCameraMove=function(e){var n=new r.Vector2(0,0),t=this.terrain.getHeight(this.camera.position.x,this.camera.position.z);this.controls.KeysPressed.w&&(n.y+=1),this.controls.KeysPressed.s&&(n.y-=1),this.controls.KeysPressed.q&&(n.x-=1),this.controls.KeysPressed.e&&(n.x+=1),this.controls.KeysPressed.a&&(this.camera.rotation.y+=2.5*e),this.controls.KeysPressed.d&&(this.camera.rotation.y-=2.5*e),n.rotateAround(new r.Vector2,this.camera.rotation.y);let i=1;if(this.terrain.isWater(t))t=Math.max(t,3.5),i=3;else{let e=this.terrain.getHeight(this.camera.position.x+n.x,this.camera.position.z+n.y),r=Math.abs(e-t);i=Math.min(Math.max(1,3*r),3)}if(n.length()>0&&(n.normalize(),n.multiplyScalar(this.acceleration*e)),this.speed.length()>0){let t=new r.Vector2;t.set(this.speed.x,this.speed.y),t.multiplyScalar(this.drag*e*i),n.add(t)}this.speed.add(n),this.camera.position.x+=this.speed.x*e,this.camera.position.z-=this.speed.y*e;var a=t+this.preferredZoom-this.camera.position.y;this.camera.position.y+=a*e*5},this.camera=new r.PerspectiveCamera(75,window.innerWidth/window.innerHeight,.1,2e3),this.camera.position.x=96,this.camera.position.z=33,this.controls=n,this.terrain=t,e.add(this.camera)}}},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.Controls=void 0;n.Controls=class{constructor(){this.KeysPressed={w:!1,a:!1,s:!1,d:!1,q:!1,e:!1,f:!1};let e=this.KeysPressed,n=this;window.onblur=function(){e.w=e.a=e.s=e.d=!1},window.onkeydown=function(t){switch(t.keyCode){case 87:case 38:e.w=!0;break;case 65:case 37:e.a=!0;break;case 83:case 40:e.s=!0;break;case 68:case 39:e.d=!0;break;case 81:e.q=!0;break;case 69:e.e=!0;break;case 70:e.f=!0,n.flashLight=!n.flashLight;default:return!0}return!1},window.onkeyup=function(n){switch(n.keyCode){case 87:case 38:e.w=!1;break;case 65:case 37:e.a=!1;break;case 83:case 40:e.s=!1;break;case 68:case 39:e.d=!1;break;case 81:e.q=!1;break;case 69:e.e=!1;break;case 70:e.f=!1;default:return!0}return!1},window.onwheel=function(e){n.camera&&.25==n.camera.camera.rotation.x&&(n.camera.preferredZoom-=.01*e.deltaY,n.camera.preferredZoom<1&&(n.camera.preferredZoom=1),n.camera.preferredZoom>1800&&(n.camera.preferredZoom=1800))}}}}]);
//# sourceMappingURL=bundle.js.map